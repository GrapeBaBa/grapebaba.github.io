<!doctype html><html lang=en-us><head><title>Where is your blockchain state | Grapebaba's Home</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Dapp状态去哪了 🔗世界状态 🔗我们知道区块链每一笔执行成功的交易，背后都对应着世界状态的变化；可以是资产所有权的变更，亦或是账户余额的变化。"><meta name=generator content="Hugo 0.110.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","281165273grape@gmail.com","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class=navigation><a href=/><span class=arrow>←</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a>
<a class=button href=https://grapebaba.github.io/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>Where is your blockchain state</h1><div class=tip><time datetime="2023-02-28 10:33:50 +0800 +0800">Feb 28, 2023</time>
<span class=split>·</span>
<span>6053 words</span>
<span class=split>·</span>
<span>13 minute read</span></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#世界状态>世界状态</a></li><li><a href=#状态读写抽象>状态读写抽象</a><ul><li><a href=#fabric中的状态读写接口><code>Fabric</code>中的状态读写接口</a></li><li><a href=#solidity中的状态变量><code>Solidity</code>中的状态变量</a></li></ul></li><li><a href=#状态数据库>状态数据库</a><ul><li><a href=#fabric数据库中的key和value><code>Fabric</code>数据库中的<code>KEY</code>和<code>VALUE</code></a></li><li><a href=#go-ethereum数据库中的key和value><code>Go-ethereum</code>数据库中的<code>KEY</code>和<code>VALUE</code></a></li></ul></li><li><a href=#内存中的状态>内存中的状态</a><ul><li><a href=#全局缓存>全局缓存</a></li><li><a href=#区块执行时的状态>区块执行时的状态</a></li></ul></li><li><a href=#结语>结语</a></li></ul></nav></div></details></aside><div class=content><h1 id=dapp状态去哪了><code>Dapp</code>状态去哪了 <a href=#dapp%e7%8a%b6%e6%80%81%e5%8e%bb%e5%93%aa%e4%ba%86 class=anchor>🔗</a></h1><h2 id=世界状态>世界状态 <a href=#%e4%b8%96%e7%95%8c%e7%8a%b6%e6%80%81 class=anchor>🔗</a></h2><p>我们知道区块链每一笔执行成功的交易，背后都对应着世界状态的变化；可以是资产所有权的变更，亦或是账户余额的变化。作为<code>dapp</code>开发人员，你可能只关心自己合约的状态，而整个区块链是如何组织和存储世界状态的呢？</p><h2 id=状态读写抽象>状态读写抽象 <a href=#%e7%8a%b6%e6%80%81%e8%af%bb%e5%86%99%e6%8a%bd%e8%b1%a1 class=anchor>🔗</a></h2><p>如果写过智能合约，我们会发现绝大多数的区块链底层都提供了最基础的<code>KV</code>存储模型。</p><h3 id=fabric中的状态读写接口><code>Fabric</code>中的状态读写接口 <a href=#fabric%e4%b8%ad%e7%9a%84%e7%8a%b6%e6%80%81%e8%af%bb%e5%86%99%e6%8e%a5%e5%8f%a3 class=anchor>🔗</a></h3><p>如果你开发过<code>Fabric</code>的<code>chaincode</code>，你肯定使用过下面的接口。非常明确的将状态读写接口暴露给<code>chaincode</code>开发人员。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>GetState<span style=color:#bbb> </span>returns<span style=color:#bbb> </span>the<span style=color:#bbb> </span>value<span style=color:#bbb> </span>of<span style=color:#bbb> </span>the<span style=color:#bbb> </span>specified<span style=color:#bbb> </span><span style=color:#666>`</span><span style=color:#a2f;font-weight:700>key</span><span style=color:#666>`</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>from</span><span style=color:#bbb> </span>the<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>ledger.<span style=color:#bbb> </span>Note<span style=color:#bbb> </span>that<span style=color:#bbb> </span>GetState<span style=color:#bbb> </span>doesn<span style=color:#b44>&#39;t read data from the writeset, which
</span></span></span><span style=display:flex><span><span style=color:#b44>	// has not been committed to the ledger. In other words, GetState doesn&#39;</span>t<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>consider<span style=color:#bbb> </span>data<span style=color:#bbb> </span>modified<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>by</span><span style=color:#bbb> </span>PutState<span style=color:#bbb> </span>that<span style=color:#bbb> </span>has<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>not</span><span style=color:#bbb> </span>been<span style=color:#bbb> </span>committed.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>If</span><span style=color:#bbb> </span>the<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>key</span><span style=color:#bbb> </span>does<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>not</span><span style=color:#bbb> </span>exist<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>in</span><span style=color:#bbb> </span>the<span style=color:#bbb> </span>state<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>database</span>,<span style=color:#bbb> </span>(nil,<span style=color:#bbb> </span>nil)<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>is</span><span style=color:#bbb> </span>returned.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#00a000>GetState</span>(<span style=color:#a2f;font-weight:700>key</span><span style=color:#bbb> </span>string)<span style=color:#bbb> </span>([]byte,<span style=color:#bbb> </span>error)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>PutState<span style=color:#bbb> </span>puts<span style=color:#bbb> </span>the<span style=color:#bbb> </span>specified<span style=color:#bbb> </span><span style=color:#666>`</span><span style=color:#a2f;font-weight:700>key</span><span style=color:#666>`</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>and</span><span style=color:#bbb> </span><span style=color:#666>`</span>value<span style=color:#666>`</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>into</span><span style=color:#bbb> </span>the<span style=color:#bbb> </span>transaction<span style=color:#b44>&#39;s
</span></span></span><span style=display:flex><span><span style=color:#b44>	// writeset as a data-write proposal. PutState doesn&#39;</span>t<span style=color:#bbb> </span>effect<span style=color:#bbb> </span>the<span style=color:#bbb> </span>ledger<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>until<span style=color:#bbb> </span>the<span style=color:#bbb> </span>transaction<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>is</span><span style=color:#bbb> </span>validated<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>and</span><span style=color:#bbb> </span>successfully<span style=color:#bbb> </span>committed.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>Simple<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>keys</span><span style=color:#bbb> </span>must<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>not</span><span style=color:#bbb> </span>be<span style=color:#bbb> </span>an<span style=color:#bbb> </span>empty<span style=color:#bbb> </span>string<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>and</span><span style=color:#bbb> </span>must<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>not</span><span style=color:#bbb> </span>start<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>with</span><span style=color:#bbb> </span>a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span><span style=color:#800>null</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>character</span><span style=color:#bbb> </span>(<span style=color:#666>0</span>x00)<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>order</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>to</span><span style=color:#bbb> </span>avoid<span style=color:#bbb> </span>range<span style=color:#bbb> </span>query<span style=color:#bbb> </span>collisions<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>with</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>composite<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>keys</span>,<span style=color:#bbb> </span>which<span style=color:#bbb> </span>internally<span style=color:#bbb> </span>get<span style=color:#bbb> </span>prefixed<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>with</span><span style=color:#bbb> </span><span style=color:#666>0</span>x00<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>as</span><span style=color:#bbb> </span>composite<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>key</span><span style=color:#bbb> </span>namespace.<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>In</span><span style=color:#bbb> </span>addition,<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>if</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>using</span><span style=color:#bbb> </span>CouchDB,<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>keys</span><span style=color:#bbb> </span>can<span style=color:#bbb> </span>only<span style=color:#bbb> </span>contain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>//</span><span style=color:#bbb> </span>valid<span style=color:#bbb> </span>UTF<span style=color:#666>-</span><span style=color:#666>8</span><span style=color:#bbb> </span>strings<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>and</span><span style=color:#bbb> </span>cannot<span style=color:#bbb> </span>begin<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>with</span><span style=color:#bbb> </span>an<span style=color:#bbb> </span><span style=color:#00a000>underscore</span><span style=color:#bbb> </span>(<span style=color:#b44>&#34;_&#34;</span>).<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#00a000>PutState</span>(<span style=color:#a2f;font-weight:700>key</span><span style=color:#bbb> </span>string,<span style=color:#bbb> </span>value<span style=color:#bbb> </span>[]byte)<span style=color:#bbb> </span>error<span style=color:#bbb>
</span></span></span></code></pre></div><p>查看底层处理状态读写的代码，我们可以看到底层的存储接口增加了<code>namespace</code>的前缀，这个<code>namespace</code>实际上对应的是<code>chaincodeID</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>func (q *queryExecutor) getState(ns, key string) ([]byte, []byte, error) {
</span></span><span style=display:flex><span>	if err := q.checkDone(); err != nil {
</span></span><span style=display:flex><span>		return nil, nil, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	versionedValue, err := q.txmgr.db.GetState(ns, key)
</span></span><span style=display:flex><span>	if err != nil {
</span></span><span style=display:flex><span>		return nil, nil, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	val, metadata, ver := decomposeVersionedValue(versionedValue)
</span></span><span style=display:flex><span>	if q.collectReadset {
</span></span><span style=display:flex><span>		q.rwsetBuilder.AddToReadSet(ns, key, ver)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	return val, metadata, nil
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// SetState implements method in interface `ledger.TxSimulator`
</span></span><span style=display:flex><span>func (s *txSimulator) SetState(ns string, key string, value []byte) error {
</span></span><span style=display:flex><span>	if err := s.checkWritePrecondition(key, value); err != nil {
</span></span><span style=display:flex><span>		return err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	s.rwsetBuilder.AddToWriteSet(ns, key, value)
</span></span><span style=display:flex><span>	return nil
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solidity中的状态变量><code>Solidity</code>中的状态变量 <a href=#solidity%e4%b8%ad%e7%9a%84%e7%8a%b6%e6%80%81%e5%8f%98%e9%87%8f class=anchor>🔗</a></h3><p>而你如果使用<code>Solidity</code>编写过智能合约，你可能会发现并没有明确的状态读写接口，但是你一定会用到<code>State Variables</code>。状态变量的读写在<code>EVM</code>的执行过程中会对应到指令码<code>SLOAD</code>和<code>SSTORE</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>contract ExampleContract { 
</span></span><span style=display:flex><span>    uint storedData; // State variable
</span></span><span style=display:flex><span>    event Sent ( msg ); 
</span></span><span style=display:flex><span>    constructor () public {}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    function method ( uint x) public { 
</span></span><span style=display:flex><span>        storeData = x;
</span></span><span style=display:flex><span>        emit Sent (&#39;Success&#39;);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>查看<code>hyperledger/burrow</code>项目实现的<code>EVM</code>，我们可以看到实际底层也是类似的<code>KV</code>存储。同样的我们发现在底层存储中增加了<code>params.Callee</code>这样一个类似的<code>namespace</code>，这里对应的其实是合约账户地址。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>case SLOAD: // 0x54
</span></span><span style=display:flex><span>    loc := stack.Pop()
</span></span><span style=display:flex><span>    data := LeftPadWord256(maybe.Bytes(st.CallFrame.GetStorage(params.Callee, loc)))
</span></span><span style=display:flex><span>    stack.Push(data)
</span></span><span style=display:flex><span>    c.debugf(&#34;%v {0x%v = 0x%v}\n&#34;, params.Callee, loc, data)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>case SSTORE: // 0x55
</span></span><span style=display:flex><span>    loc, data := stack.Pop(), stack.Pop()
</span></span><span style=display:flex><span>    maybe.PushError(engine.UseGasNegative(params.Gas, engine.GasStorageUpdate))
</span></span><span style=display:flex><span>	maybe.PushError(st.CallFrame.SetStorage(params.Callee, loc, data.Bytes()))
</span></span><span style=display:flex><span>    c.debugf(&#34;%v {%v := %v}\n&#34;, params.Callee, loc, data)
</span></span></code></pre></div><h2 id=状态数据库>状态数据库 <a href=#%e7%8a%b6%e6%80%81%e6%95%b0%e6%8d%ae%e5%ba%93 class=anchor>🔗</a></h2><p>前面我们已经知道了合约中的状态读写接口是怎么和区块链底层关联的，但是状态又是如何持久化到状态数据库中的呢？绝大部分的区块链都是使用的<code>KV</code>数据库来作为状态数据库，但是也有一些区块链支持关系数据库和文档数据库等。</p><p>我们这里只介绍<code>KV</code>状态数据库，下面以<code>Fabric</code>和<code>Go-ethereum</code>为例子来看看它们是如何处理的。因为<code>KV</code>是非常简单的模型，我们只要搞清楚<code>KEY</code>和<code>VALUE</code>是如何编解码的，我们就能理解整个区块链中的状态管理。</p><h3 id=fabric数据库中的key和value><code>Fabric</code>数据库中的<code>KEY</code>和<code>VALUE</code> <a href=#fabric%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e7%9a%84key%e5%92%8cvalue class=anchor>🔗</a></h3><p>首先我们需要知道<code>Fabric</code>中有<code>channel</code>和<code>chaincode</code>的概念，每一个<code>channel</code>对应于一条独立的区块链，每一个<code>chaincode</code>对应于一个独立的智能合约。在内存中<code>Fabric</code>会使用多级<code>Map</code>的数据结构来组织整个状态数据，而其实底层只使用一个<code>KV</code>数据库作为状态数据库。</p><p>其中<code>KEY</code>的编码是将内存中的层级结构铺平，由<code>channelID</code>，<code>chaincodeID</code>和用户自己定义的<code>key</code>拼接而成。</p><blockquote><p>channelID + chaincodeID + user_defined_key</p></blockquote><p>而<code>VALUE</code>的编码则是和<code>RWSet</code>紧密相关，可通过官方文档<a href=https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html target=_blank rel=noopener>Read-Write set semantics</a>章节了解<code>RWSet</code>的概念。</p><p>根据下面的<code>proto</code>数据结构定义，可以看出实际数据库中的<code>VALUE</code>除了包含用户自定义的<code>Value</code>，还包括了<code>Version</code>和<code>Metadata</code>两个附加的值，而<code>Version</code>的值实际上是<code>Height</code>编码后的内容。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type DBValue struct {
</span></span><span style=display:flex><span>	Version              []byte   `protobuf:&#34;bytes,1,opt,name=version,proto3&#34; json:&#34;version,omitempty&#34;`
</span></span><span style=display:flex><span>	Value                []byte   `protobuf:&#34;bytes,2,opt,name=value,proto3&#34; json:&#34;value,omitempty&#34;`
</span></span><span style=display:flex><span>	Metadata             []byte   `protobuf:&#34;bytes,3,opt,name=metadata,proto3&#34; json:&#34;metadata,omitempty&#34;`
</span></span><span style=display:flex><span>	XXX_NoUnkeyedLiteral struct{} `json:&#34;-&#34;`
</span></span><span style=display:flex><span>	XXX_unrecognized     []byte   `json:&#34;-&#34;`
</span></span><span style=display:flex><span>	XXX_sizecache        int32    `json:&#34;-&#34;`
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type Height struct {
</span></span><span style=display:flex><span>	BlockNum uint64
</span></span><span style=display:flex><span>	TxNum    uint64
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=go-ethereum数据库中的key和value><code>Go-ethereum</code>数据库中的<code>KEY</code>和<code>VALUE</code> <a href=#go-ethereum%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e7%9a%84key%e5%92%8cvalue class=anchor>🔗</a></h3><p>如果稍微了解过<code>Ethereum</code>，应该知道<code>Ethereum</code>中有一个特别的数据结构<a href=https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/ target=_blank rel=noopener>PATRICIA MERKLE TREES</a>。<code>MPT</code>实际被应用到多个模块，而和状态密切相关的，主要是<code>World State Trie</code>和<code>Storage Trie</code>。</p><p>虽然<code>PATRICIA MERKLE TREES</code>有<code>Branch node</code>，<code>Extension node</code>和<code>Leaf node</code>等多种类型(不讨论<code>NULL</code>节点)；同时在<code>Ethereum</code>中每一个<code>Address</code>都对应了一棵<code>World State Trie</code>，并且如果<code>Address</code>是一个合约地址，还同时对应了一棵<code>Storage Trie</code>。但是对于状态数据库中的<code>KEY</code>和<code>VALUE</code>编码，实际上可以只用一条统一的规则描述。</p><blockquote><p>𝑘𝑒𝑐𝑐𝑎𝑘 (𝑅𝐿𝑃 (𝑛𝑜𝑑𝑒)) → 𝑅𝐿𝑃 (𝑛𝑜𝑑𝑒)</p></blockquote><p><code>𝑘𝑒𝑐𝑐𝑎𝑘</code>是<code>Ethereum</code>使用的<code>hash</code>算法，而<a href=https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/ target=_blank rel=noopener>𝑅𝐿𝑃</a>是<code>Ethereum</code>使用的编解码格式。</p><ul><li>Extension 𝑛𝑜𝑑𝑒 ≡ [𝐻𝑃 (𝑝𝑟𝑒𝑓𝑖𝑥 + 𝑝𝑎𝑡ℎ), 𝑘𝑒𝑦]</li><li>Branch 𝑛𝑜𝑑𝑒 ≡ [𝑏𝑟𝑎𝑛𝑐ℎ𝑒𝑠, 𝑣𝑎𝑙𝑢𝑒]</li><li>Leaf 𝑛𝑜𝑑𝑒 ≡ [𝐻𝑃 (𝑝𝑟𝑒𝑓𝑖𝑥 + 𝑝𝑎𝑡ℎ), 𝑣𝑎𝑙𝑢𝑒]</li></ul><p><code>𝐻𝑃</code>代表的是<code>Hex Prefix Encoding</code>，<code>𝑝𝑟𝑒𝑓𝑖𝑥</code>指的是用于区分不同的<code>Extension</code>和<code>Leaf</code>的<code>node</code>的标志位。</p><p>从上述的规则我们可以看到，<code>Ethereum</code>的状态数据库是把所有<code>MPT</code>的节点进行了存储，而对应<code>KEY</code>是节点编码后的<code>hash</code>值，而<code>VALUE</code>就是节点编码的实际值。</p><h2 id=内存中的状态>内存中的状态 <a href=#%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e7%8a%b6%e6%80%81 class=anchor>🔗</a></h2><p>前面我们说到了面向用户的状态读写抽象和状态是如何被持久化到数据库中的，下面我们来说一说位于两者中间的内存中的状态。</p><h3 id=全局缓存>全局缓存 <a href=#%e5%85%a8%e5%b1%80%e7%bc%93%e5%ad%98 class=anchor>🔗</a></h3><p>类似操作系统或者数据库系统，为了提升效率，区块链会将状态数据库中的数据在内存中进行缓存。全局的缓存通常是一个有序<code>Map</code>的数据结构，缓存的内容实际就是数据库中的<code>KEY</code>和<code>VALUE</code>。</p><h3 id=区块执行时的状态>区块执行时的状态 <a href=#%e5%8c%ba%e5%9d%97%e6%89%a7%e8%a1%8c%e6%97%b6%e7%9a%84%e7%8a%b6%e6%80%81 class=anchor>🔗</a></h3><p>区块的执行实际就是执行该区块中的全部交易，交易在执行时都是从当前最新的世界状态中去读取数据，而将对状态的变更先更新到当前执行上下文的内存数据结构中；当全部交易执行完成后，将当前上下文中变更了的状态整个提交到状态数据库和全局缓存中。下面我们还是以<code>Fabric</code>和<code>Go-ethereum</code>为例子来看看它们分别是怎么处理的。</p><h4 id=fabric内存中的状态表示><code>Fabric</code>内存中的状态表示 <a href=#fabric%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e7%8a%b6%e6%80%81%e8%a1%a8%e7%a4%ba class=anchor>🔗</a></h4><p><code>Fabric</code>的整体执行流程是<code>Execute</code>-><code>Orderer</code>-><code>Validate</code>方式，因此它的交易内容中的<code>RWSet</code>，实际上是该交易执行时读写过的状态，每笔交易执行时读取的状态都是以上一个区块提交后的世界状态为基准，写入的状态则写入到当前交易上下文的<code>WSet</code>中。因为所有交易的读取都是以上一个区块提交后的世界状态为基准，所以可能存在状态更新冲突的交易（还是参考<a href=https://hyperledger-fabric.readthedocs.io/en/latest/readwrite.html target=_blank rel=noopener>Read-Write set semantics</a>），在<code>Validate</code>阶段进行<code>MVCC</code>验证过程中，会保证冲突的交易只有一笔能够成功。而验证完后的结果实际上就得到了一个<code>Batch</code>对象，保存了所有成功交易变更过的状态的集合。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#666>//</span><span style=color:#bbb> </span>UpdateBatch<span style=color:#bbb> </span>encapsulates<span style=color:#bbb> </span>the<span style=color:#bbb> </span>updates<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>to</span><span style=color:#bbb> </span>Public,<span style=color:#bbb> </span>Private,<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>and</span><span style=color:#bbb> </span>Hashed<span style=color:#bbb> </span>data.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>//</span><span style=color:#bbb> </span>This<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>is</span><span style=color:#bbb> </span>expected<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>to</span><span style=color:#bbb> </span>contain<span style=color:#bbb> </span>a<span style=color:#bbb> </span>consistent<span style=color:#bbb> </span><span style=color:#0b0;font-weight:700>set</span><span style=color:#bbb> </span>of<span style=color:#bbb> </span>updates<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>type<span style=color:#bbb> </span>UpdateBatch<span style=color:#bbb> </span>struct<span style=color:#bbb> </span><span>{</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>PubUpdates<span style=color:#bbb>  </span><span style=color:#666>*</span>PubUpdateBatch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>HashUpdates<span style=color:#bbb> </span><span style=color:#666>*</span>HashedUpdateBatch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>PvtUpdates<span style=color:#bbb>  </span><span style=color:#666>*</span>PvtUpdateBatch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span>}</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>//</span><span style=color:#bbb> </span>PubUpdateBatch<span style=color:#bbb> </span>contains<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>update</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>for</span><span style=color:#bbb> </span>the<span style=color:#bbb> </span>public<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>type<span style=color:#bbb> </span>PubUpdateBatch<span style=color:#bbb> </span>struct<span style=color:#bbb> </span><span>{</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span><span style=color:#666>*</span>statedb.UpdateBatch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span>}</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>//</span><span style=color:#bbb> </span>UpdateBatch<span style=color:#bbb> </span>encloses<span style=color:#bbb> </span>the<span style=color:#bbb> </span>details<span style=color:#bbb> </span>of<span style=color:#bbb> </span>multiple<span style=color:#bbb> </span><span style=color:#666>`</span>updates<span style=color:#666>`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>type<span style=color:#bbb> </span>UpdateBatch<span style=color:#bbb> </span>struct<span style=color:#bbb> </span><span>{</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>ContainsPostOrderWrites<span style=color:#bbb> </span><span style=color:#0b0;font-weight:700>bool</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>Updates<span style=color:#bbb>                 </span>map[string]<span style=color:#666>*</span>nsUpdates<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span>}</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>type<span style=color:#bbb> </span>nsUpdates<span style=color:#bbb> </span>struct<span style=color:#bbb> </span><span>{</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>M<span style=color:#bbb> </span>map[string]<span style=color:#666>*</span>VersionedValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span>}</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>这里我们不讲<code>HashedUpdateBatch</code>和<code>PvtUpdates</code>(与其内部其他特性有关)，我们可以看到<code>PubUpdates</code>实际上就是一个两级的<code>Map</code>结构，外层的<code>KEY</code>就是<code>chaincodeID</code>，内层的<code>KEY</code>就是用户在调用<code>PutState</code>方法传入的<code>KEY</code>。这里我们没有看到<code>channelID</code>这个维度，是因为每个<code>channel</code>实际上都是独立的区块链，所以一个区块中是不可能包含其他<code>channel</code>的状态变更的，在最后<code>Batch</code>写入状态数据库的时候会统一的把这个区块所在的<code>channelID</code>拼接上。</p><h4 id=go-ethereum内存中的状态表示><code>Go-ethereum</code>内存中的状态表示 <a href=#go-ethereum%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e7%8a%b6%e6%80%81%e8%a1%a8%e7%a4%ba class=anchor>🔗</a></h4><h6 id=merkle-patricia-trie简介><code>MERKLE PATRICIA TRIE</code>简介 <a href=#merkle-patricia-trie%e7%ae%80%e4%bb%8b class=anchor>🔗</a></h6><p>在<code>MPT</code>中有三种<code>node</code>类型(不考虑<code>NULL</code>节点)</p><ul><li>Branch – a 17-item node [𝑖0,𝑖1, &mldr;,𝑖15, 𝑣𝑎𝑙𝑢𝑒]</li><li>Extension – A 2-item node [𝑝𝑎𝑡ℎ, 𝑘𝑒𝑦]</li><li>Leaf – A 2-item node [𝑝𝑎𝑡ℎ, 𝑣𝑎𝑙𝑢𝑒]</li></ul><blockquote><p>The Branch node is used where branching takes place, i.e. keys at certain character position starts to differ. First 16
items are used for branching, which means that this node allows for 16 possible branches for 0 ′ 𝐹 hex character. This
concept is familiar from the Memory Trie structures, where branching was constructed as a column in a table. The
𝑖∀position contains a link to a child node whenever the child exists, i.e. this position corresponds with a next character
(hex 0 ′ 𝐹 ) in a key. The 17th item stores a value and it is used only if this node is terminating (for a certain key).</p></blockquote><p>我们可以看到<code>Branch</code>节点的前16个<code>item</code>会存储<code>child node</code>的指针（实际就是<code>child node</code>的𝑘𝑒𝑐𝑐𝑎𝑘 (𝑅𝐿𝑃 (𝑛𝑜𝑑𝑒))），所以我们可以通过这个指针从状态数据库或者是全局缓存中加载并解码得到<code>child node</code>对象，以此类推我们可以在内存中逐步构建出<code>MPT</code>（实际上我们只会加载本次区块执行过程中所有交易读写过的节点）。而最后一个<code>item</code>是用来存储<code>value</code>的，这个<code>value</code>存储的不是一个节点指针而是一个实际的值。<code>value</code>可以看后面一个例子。</p><blockquote><p>The Extension node is where the compression takes place. Whenever there is a part common for multiple keys, this
part is stored in this node. In other words, it prevents descending several times should it follow only one path. This
node, in other words, resembles a Patricia feature of number of bits to skip.</p></blockquote><p><code>Extension</code>的作用非常明显，就是用于减少<code>path</code>上公共前缀的存储，压缩<code>path</code>。其中<code>path item</code>存储的是公共前缀，<code>value</code>是存储的是一个节点指针，同样可以根据这个指针加载出新的节点。</p><blockquote><p>The Leaf node terminates the path in the tree. It also uses a compression as it groups common suffixes for keys in
the 𝑝𝑎𝑡ℎ, which is a concept re-used again from Memory Trie.</p></blockquote><p><code>Leaf</code>用于存储实际的值。</p><p>从下面这个例子可以直观的看到<code>Branch node</code>中<code>value</code>存储的是<code>KEY</code>正好匹配到<code>EXTENSION</code>公共前缀对应的值。同时<code>Leaf node</code>中的前缀<code>10</code>代表的<code>path</code>是偶数长度的叶子节点类型（关于前缀的部分可以参考<a href=https://ethereum.github.io/yellowpaper/paper.pdf target=_blank rel=noopener>Yellow Paper</a>中
<code>Appendix C. Hex-Prefix Encoding</code>部分）。<p class=markdown-image><img src=https://i.imgur.com/Vmi1dRM.png alt></p></p><h6 id=mpt的构建><code>MPT</code>的构建 <a href=#mpt%e7%9a%84%e6%9e%84%e5%bb%ba class=anchor>🔗</a></h6><p><code>Go-ethereum</code>内存中的状态表示其实之前已经提到了，就是<code>World State Trie</code>和<code>Storage Trie</code>。<code>Go-ethereum</code>中的状态变量和状态数据库中存储的<code>KEY</code>和<code>VALUE</code>看起来似乎没有明显的关联，用户不需要自己定义<code>KEY</code>，那状态变量的值是怎么跑到<code>Storage Trie</code>的节点里的呢？</p><p>我们从下面这张整体的图中，我们可以看到<code>Storage Trie</code>的<code>root</code>是存储在对应的<code>World State Trie</code>的<code>node</code>里的，而<code>World State Trie</code>的<code>root</code>是存储在对应的<code>Block header</code>里的。<p class=markdown-image><img src=https://i.imgur.com/ctszYuo.png alt></p></p><p>当我们执行一个新的区块时，我们需要从上一个区块的<code>Block header</code>中取出最新的<code>World State Trie</code>的<code>root</code>，这个<code>root</code>实际上就是<code>𝑘𝑒𝑐𝑐𝑎𝑘 (𝑅𝐿𝑃 (𝑛𝑜𝑑𝑒))</code>，这样我们就可以从状态数据库或者是全局缓存中加载出<code>World State Trie</code>的<code>𝑅𝐿𝑃 (𝑛𝑜𝑑𝑒)</code>，解码后我们就得到了实际的<code>root node</code>对象。以此类推，我们就可以从<code>root node</code>开始，通过节点中存储的<code>child node</code>指针，加载出需要用到的<code>World State Trie</code>节点。因为<code>World State Trie</code>的<code>Leaf node</code>中存储的<code>value</code>实际上就是<code>Go-ethereum</code>中的<code>Account</code>对象，当这个<code>Account</code>对象对应的是一个合约的时候，它的<code>storageRoot</code>字段存储的就是<code>Storage Trie</code>的<code>root</code>。同理，我们就可以加载出用到的<code>Storage Trie</code>节点。</p><h6 id=world-state-trie中的key和value><code>World State Trie</code>中的<code>KEY</code>和<code>VALUE</code> <a href=#world-state-trie%e4%b8%ad%e7%9a%84key%e5%92%8cvalue class=anchor>🔗</a></h6><p><code>World State Trie</code>中的<code>KEY</code>和<code>VALUE</code>可以描述为</p><blockquote><p>𝑘𝑒𝑐𝑐𝑎𝑘 (𝑎𝑑𝑑𝑟𝑒𝑠𝑠) → 𝑅𝐿𝑃 (𝐴)</p></blockquote><p><code>KEY</code>的值是20字节的<code>Address</code>生成32字节的哈希，然后经过<code>HEX</code>编码后，映射到<code>World State Trie</code>的路径。而<code>Leaf</code>节点中存储的值是<code>𝑅𝐿𝑃 (𝐴)</code>，这个<code>A</code>就是我们前面提到的<code>Account</code>对象。</p><p><code>Account</code>对象中包含如下属性</p><ul><li>nonce
是一个自增的整数，对于外部账号，这个值代表从这个地址发出过的交易数；而对于合约账号，这个值代表合约的创建次数。</li><li>balance
代表账户中的余额。</li><li>storageRoot
外部账户这个值为空，合约账号这个值存储了<code>Storage Trie</code>的根节点哈希。</li><li>codeHash
外部账户这个值为空，合约账号这个值对应合约源代码的哈希。</li></ul><h6 id=storage-trie中的key和value><code>Storage Trie</code>中的<code>KEY</code>和<code>VALUE</code> <a href=#storage-trie%e4%b8%ad%e7%9a%84key%e5%92%8cvalue class=anchor>🔗</a></h6><p><code>Storage Trie</code>的<code>KEY</code>和<code>VALUE</code>是最复杂的，因为这里和<code>Solidity</code>的数据类型布局紧密相关，用一个通用的方式描述如下</p><blockquote><p>𝑘𝑒𝑐𝑐𝑎𝑘 (𝑖𝑛𝑑𝑒𝑥) → 𝑅𝐿𝑃 (𝑠𝑙𝑜𝑡)</p></blockquote><p><code>Storage Trie</code>中的<code>Leaf</code>节点存储的值就是<code>slot</code>，这个<code>slot</code>实际上就是一个长度32的字节数组，而<code>index</code>就是用于定位这个<code>slot</code>的值（可能就是<code>slot</code>的序号，也可能是(序号+key)）。<code>slot</code>的序号就是根据我们<code>Solidity</code>代码中定义的<code>State Variables</code>的顺序产生。</p><p><code>KEY</code>的实际值就是<code>index</code>的哈希，然后经过<code>HEX</code>编码后，我们就能将<code>KEY</code>映射成<code>Storage Trie</code>的<code>path</code>，然后将<code>slot</code>存储到<code>Storage Trie</code>的<code>Leaf</code>节点中。</p><p>下面看看不同类型的<code>slot</code>的例子，更详细的描述请参考<code>Solidity</code>官方文档<a href=https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html target=_blank rel=noopener>layout_in_storage</a>章节。</p><ul><li>Statically Sized Variables<p class=markdown-image><img src=https://i.imgur.com/4PgJlD4.png alt></p></li></ul><p>定长类型的变量会根据类型长度，多个变量共享或者单个变量独占一个<code>slot</code>。</p><ul><li>Maps<p class=markdown-image><img src=https://i.imgur.com/Zvl7wiT.png alt></p></li></ul><p><code>Map</code>的<code>index</code>包含了用户<code>key</code>，从这个布局中我们就能看到实际上并没有存储用户<code>key</code>的原值，同时也没有存储<code>Map</code>的<code>size</code>，所有我们在<code>Solidity</code>中不能直接迭代<code>mapping</code>。</p><ul><li>Dynamic Arrays<p class=markdown-image><img src=https://i.imgur.com/igt0gMm.png alt></p></li></ul><p>动态数组的<code>index</code>包含了数组中的位置，同时还存储了数组的<code>size</code>。</p><ul><li>Byte Arrays and String<p class=markdown-image><img src=https://i.imgur.com/aBB0JJL.png alt></p></li></ul><p>对于字节数组和字符串，如果长度小于32，就用一个<code>slot</code>存储，同时最后一个字节存储实际长度。如果长度更长，则使用和动态数组一样的方式存储。</p><h6 id=mpt的提交><code>MPT</code>的提交 <a href=#mpt%e7%9a%84%e6%8f%90%e4%ba%a4 class=anchor>🔗</a></h6><p>在区块所有交易执行完成后，所有成功执行的交易导致变化过的<code>MPT</code>节点，最后会统一更新到状态数据库和全局缓存。根据<code>Ethereum</code>数据库中的<code>KEY</code>和<code>VALUE</code>的内容，我们知道了对于底层数据库来说实际只会新插入数据（状态膨胀问题）。同时我们还要注意，因为<code>Leaf</code>中的值改变了，导致<code>Leaf</code>节点内容变化了，<code>Leaf</code>节点的<code>hash</code>也变化了，意味着<code>Branch</code>节点中的节点指针也变化了，所以<code>Branch</code>节点的内容实际也变化了，以此类推，一直会得到一个变化了的<code>root</code>。这个正是<code>MPT</code>结构中<code>Merkle tree</code>的体现，利用这个性质，我们可以通过<code>Merkle proof</code>来证明<code>MPT</code>节点的存在性。所以<code>MPT</code>是一种<code>Authenticated Storage</code>，对于拥有<code>Light client</code>的链来说，是一种必要的属性。</p><h2 id=结语>结语 <a href=#%e7%bb%93%e8%af%ad class=anchor>🔗</a></h2><p>随着<code>Fabric</code>和<code>Go-ethereum</code>的不断更新迭代，上述内容可能会过时，但是不妨碍我们了解到区块链中对于状态管理的整体的设计思路。实际上针对状态膨胀问题<code>Go-ethereum</code>已经在从<code>hash-based state scheme</code>切换到<a href=https://github.com/ethereum/go-ethereum/issues/25390 target=_blank rel=noopener><code>path-based state scheme</code></a>，而另一个数据结构<a href=https://blog.ethereum.org/2021/12/02/verkle-tree-structure target=_blank rel=noopener>Verkle trie</a>将很可能替换<code>MPT</code>用于解决<code>proof size</code>过大的问题。有兴趣的朋友可以自行了解。</p><p>纸上得来终觉浅，我创建了一个项目<a href=https://github.com/GrapeBaBa/verkle target=_blank rel=noopener>verkle</a>用来学习<code>verkle trie</code>，主要参考<a href=https://github.com/gballet/go-verkle target=_blank rel=noopener>go-verkle</a>。目前代码只实现了很少的一部分，有兴趣的朋友可以一起来动动手。</p></div><div class=tags><a href=https://grapebaba.github.io/tags/blockchain>Blockchain</a>
<a href=https://grapebaba.github.io/tags/hyperledger-fabric>Hyperledger fabric</a>
<a href=https://grapebaba.github.io/tags/ethereum>Ethereum</a>
<a href=https://grapebaba.github.io/tags/merkle-patricia-trie>Merkle Patricia Trie</a></div><div id=comment><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//grapebaba.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/GrapeBaBa rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://stackoverflow.com/users/3141951/grapebaba rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>stackoverflow</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-488.000000, -1163.000000)"><g id="stackoverflow" transform="translate(488.000000, 1163.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M42.0860128 53.5922927 22.9745951 53.6011499 22.9729497 49.5538824 42.0835447 49.5440929 42.0860128 53.5922927zM55 30.6708298 51.7306912 12 47.7087256 12.6920259l3.2688387 18.6708298L55 30.6708298zM42.5455518 44.3547147 23.5156994 42.616026 23.1410164 46.6470941l19.030205 1.7370572L42.5455518 44.3547147zm1.2554466-5.2815628-18.4550173-4.919234L24.285633 38.0621508l18.4563101 4.9198168 1.0590553-3.9088157zm2.4093479-4.6295108-16.4608999-9.6271776-2.0746249 3.4850693 16.4617226 9.6277603 2.0738022-3.485652zm4.0363041-2.8347655-3.3721468 2.2794433L36.106599 18.2318456l3.3726169-2.2801425L50.2466504 31.6088756zm-4.9150697 8.6695527h3.2483886V60H17V40.2784283h3.2648427V56.8243495h25.066738V40.2784283z" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://twitter.com/GrapeBaBa rel=me target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><div class=copyright>© Copyright
2023
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Grapebaba</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>